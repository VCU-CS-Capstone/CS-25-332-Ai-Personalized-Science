from flask import Flask, request, jsonify, render_template, redirect, url_for, session
from openai import OpenAI
from flask_cors import CORS
import mysql.connector
import re
import os
import requests
from dotenv import load_dotenv
import smtplib
from email.message import EmailMessage
import ssl

load_dotenv() # Load the environment variables

# Loading database and AI

client = OpenAI(
  api_key=os.getenv("OPENAI_API_KEY")
)

app = Flask(__name__)
CORS(app)
app.secret_key = os.urandom(24).hex()

dataBase = mysql.connector.connect(
  host =os.getenv("DB_HOST"),
  user =os.getenv("DB_USER"),
  passwd =os.getenv("DB_PASSWORD"),
  database =os.getenv("DB_NAME")
)

# preparing a cursor object
cursorObject = dataBase.cursor()
# creating table
userRecord = """CREATE TABLE IF NOT EXISTS users (
                   userID INT AUTO_INCREMENT PRIMARY KEY,
                   userEmail VARCHAR(255) NOT NULL,
                   userUsername VARCHAR(255) UNIQUE NOT NULL,
                   userPassword VARCHAR(255) NOT NULL
                   )"""

# table created
cursorObject.execute(userRecord)
dataBase.commit()

def sendEmail(subject, body, emailReceiver):
    emailSender = 'ai.sender.assisstant@gmail.com'
    emailPassword = os.getenv("EMAIL_PASSWORD")

    em = EmailMessage()
    em['From'] = emailSender
    em['To'] = emailReceiver
    em['Subject'] = subject
    em.set_content(body)

    context = ssl.create_default_context()

    with smtplib.SMTP_SSL('smtp.gmail.com', 465, context=context) as smtp:
        smtp.login(emailSender, emailPassword)
        smtp.sendmail(emailSender, emailReceiver, em.as_string())

def searchArxiv(query):
    """Searches arXiv with a given query and returns the top 5 most relevant papers."""
    arxivUrl = "http://export.arxiv.org/api/query"
    params = {
        "search_query": f"all:{query}",
        "start": 0,
        "max_results": 5,  # Retrieve top 5 papers
        "sortBy": "relevance"
    }
    response = requests.get(arxivUrl, params=params)

    if response.status_code != 200:
        return []  # Return empty list if request fails

    papers = []
    entries = response.text.split("<entry>")[1:]  # Split response into entries

    for entry in entries:
        titleStart = entry.find("<title>") + len("<title>")
        titleEnd = entry.find("</title>")
        title = entry[titleStart:titleEnd].strip()

        urlStart = entry.find("<id>") + len("<id>")
        urlEnd = entry.find("</id>")
        url = entry[urlStart:urlEnd].strip()

        papers.append({"title": title, "url": url, "query_match": query.lower() in title.lower()})

    # Rank results: prioritize titles that directly match the query
    papers = sorted(papers, key=lambda x: x["query_match"], reverse=True)
    return papers

# Function to generate recommendations from Gemini AI
def getRecommendations(userQuery):
    completion = client.chat.completions.create(
        model="gpt-4o",
        messages=[
            {"role": "system", "content": "You are a research assistant providing only three relevant keywords, each on a new line."},
            {"role": "user", "content": f"Generate 3 keyword search terms related to: {userQuery}"}
        ]
    )

    gpt4Response = completion.choices[0].message.content

    # Extract keywords: remove empty lines, strip spaces, and ensure uniqueness
    keywords = list(set(kw.strip() for kw in gpt4Response.split("\n") if kw.strip()))[:3]

    if not keywords:
        return {"error": "No keywords generated by GPT-4o."}

    articles = []
    oldArticles = set()  # Avoid duplicate papers

    for keyword in keywords:
        papers = searchArxiv(keyword)

        # Filter out duplicate titles
        for paper in papers:
            if paper["title"] not in oldArticles:
                articles.append(paper)
                oldArticles.add(paper["title"])


    return {
        "gpt_keywords": keywords,
        "arxiv_papers": articles if articles else "No relevant papers found."
    }

@app.route('/')
@app.route('/login', methods =['GET', 'POST'])
def login():
    # Login page to log user into account
    msg = ''
    if request.method == 'POST' and 'userUsername' in request.form and 'userPassword' in request.form:
        username = request.form['userUsername']
        password = request.form['userPassword']
        cursorObject.execute('SELECT * FROM users WHERE userUsername = %s AND userPassword = %s', (username, password))
        account = cursorObject.fetchone()
        # If account is in database it will log in, else it will get error message
        if account:
                session['loggedin'] = True
                session['id'] = account[0]
                session['username'] = account[2]
                msg = 'Logged in successfully!'
                return render_template('index.html', msg = msg)
        else:
                msg = 'Incorrect username/password!'
                return render_template('login.html', msg = msg)
    return render_template('login.html', msg = msg)


@app.route('/logout')
def logout():
    session.pop('loggedin', None)
    session.pop('id', None)
    session.pop('username', None)
    return redirect('login.html')

@app.route('/register', methods =['GET', 'POST'])
def register():
    # Page to register accounts
    msg = ''
    if request.method == 'POST' and 'userUsername' in request.form and 'userPassword' in request.form and 'userEmail' in request.form :
        username = request.form['userUsername']
        password = request.form['userPassword']
        email = request.form['userEmail']
        cursorObject.execute('SELECT * FROM users WHERE userUsername = %s', (username,))
        account = cursorObject.fetchone()
        # Determining if accounts are already made and if valid email and password
        if account:
            msg = 'Account already exists!'
        elif not re.match(r'[^@]+@[^@]+\.[^@]+', email):
            msg = 'Invalid email address!'
        elif not re.match(r'[A-Za-z0-9]+', username):
            msg = 'Username must contain only characters and numbers!'
        elif not username or not password or not email:
            msg = 'Please fill out the form!'
        else:
            cursorObject.execute('INSERT INTO users (userEmail, userUsername, userPassword) VALUES (%s, %s, %s)', (email, username, password))
            dataBase.commit()
            msg = 'You have successfully registered!'
    elif request.method == 'POST':
        msg = 'Please fill out the form!'
    return render_template('register.html', msg = msg)

@app.route('/recommend', methods=['GET'])
def recommend():
    # Determining different articles
    userQuery = request.args.get('query', default="machine learning")
    emailReceiver = request.args.get('email')
    if not userQuery:
        return jsonify({"error": "Missing query parameter"}), 400
    recommendations = getRecommendations(userQuery)
     
     # If email was provided, send the results
    if emailReceiver and isinstance(recommendations.get("arxiv_papers"), list):
        body = f"Top articles for '{userQuery}':\n\n"
        for i, paper in enumerate(recommendations["arxiv_papers"], 1):
            body += f"{i}. {paper['title']}\nLink: {paper['url']}\n\n"

        sendEmail(subject=f"Your article recommendations for: {userQuery}", body=body, emailReceiver=emailReceiver)
    return jsonify(recommendations)


if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=True)
